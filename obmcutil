    busctl -j call xyz.openbmc_project.Logging \
        "$1" \
        org.freedesktop.DBus.Properties \
        GetAll s xyz.openbmc_project.Logging.Entry
}

# delete all phosphor-logging entries
function delete_logs()
{
    busctl call xyz.openbmc_project.Logging \
        /xyz/openbmc_project/logging \
        xyz.openbmc_project.Collection.DeleteAll DeleteAll
}

# stop all targets associated with powering off a system
function stop_off_targets()
{
    systemctl stop \
        obmc-chassis-powered-off@0.target \
        obmc-host-stop-pre@0.target \
        obmc-host-stopped@0.target \
        obmc-host-stopping@0.target \
        obmc-power-off@0.target \
        obmc-power-stop-pre@0.target \
        obmc-power-stop@0.target
}

function handle_cmd()
{
    case "$1" in
        chassisoff)
            OBJECT=$STATE_OBJECT/chassis$G_INSTANCE_ID
            SERVICE=$(mapper get-service "$OBJECT")
            INTERFACE=$STATE_INTERFACE.Chassis
            PROPERTY=RequestedPowerTransition
            VALUE=$INTERFACE.Transition.Off
            G_REQUESTED_STATE=$INTERFACE.PowerState.Off
            G_QUERY="chassisstate"
            set_property "$SERVICE" "$OBJECT" $INTERFACE $PROPERTY "s" $VALUE
            ;;
        chassison)
            check_and_warn_boot_block
            OBJECT=$STATE_OBJECT/chassis$G_INSTANCE_ID
            SERVICE=$(mapper get-service "$OBJECT")
            INTERFACE=$STATE_INTERFACE.Chassis
            PROPERTY=RequestedPowerTransition
            VALUE=$INTERFACE.Transition.On
            G_REQUESTED_STATE=$INTERFACE.PowerState.On
            G_QUERY="chassisstate"
            set_property "$SERVICE" "$OBJECT" $INTERFACE $PROPERTY "s" $VALUE
            ;;
        poweroff)
            OBJECT=$STATE_OBJECT/host$G_INSTANCE_ID
            SERVICE=$(mapper get-service "$OBJECT")
            INTERFACE=$STATE_INTERFACE.Host
            PROPERTY=RequestedHostTransition
            VALUE=$INTERFACE.Transition.Off
            G_REQUESTED_STATE=$INTERFACE.HostState.Off
            G_QUERY="hoststate"
            set_property "$SERVICE" "$OBJECT" $INTERFACE $PROPERTY "s" $VALUE
            ;;
        poweron)
            check_and_warn_boot_block
            OBJECT=$STATE_OBJECT/host$G_INSTANCE_ID
            SERVICE=$(mapper get-service "$OBJECT")
            INTERFACE=$STATE_INTERFACE.Host
            PROPERTY=RequestedHostTransition
            VALUE=$INTERFACE.Transition.On
            G_REQUESTED_STATE=$INTERFACE.HostState.Running
            G_QUERY="hoststate"
            set_property "$SERVICE" "$OBJECT" $INTERFACE $PROPERTY "s" $VALUE
            ;;
        bmcstate)
            OBJECT=$STATE_OBJECT/bmc0
            SERVICE=$(mapper get-service $OBJECT)
            INTERFACE=$STATE_INTERFACE.BMC
            PROPERTY=CurrentBMCState
            state_query "$SERVICE" $OBJECT $INTERFACE $PROPERTY
            ;;
        chassisstate)
            OBJECT=$STATE_OBJECT/chassis$G_INSTANCE_ID
            SERVICE=$(mapper get-service "$OBJECT")
            INTERFACE=$STATE_INTERFACE.Chassis
            PROPERTY=CurrentPowerState
            state_query "$SERVICE" "$OBJECT" $INTERFACE $PROPERTY
            ;;
        hoststate)
            OBJECT=$STATE_OBJECT/host$G_INSTANCE_ID
            SERVICE=$(mapper get-service "$OBJECT")
            INTERFACE=$STATE_INTERFACE.Host
            PROPERTY=CurrentHostState
            state_query "$SERVICE" "$OBJECT" $INTERFACE $PROPERTY
            ;;
        osstate)
            OBJECT=$STATE_OBJECT/host$G_INSTANCE_ID
            SERVICE=$(mapper get-service "$OBJECT")
            INTERFACE=$STATE_INTERFACE.OperatingSystem.Status
            PROPERTY=OperatingSystemState
            state_query "$SERVICE" "$OBJECT" $INTERFACE $PROPERTY
            ;;
        state|status)
            for query in bmcstate chassisstate hoststate bootprogress osstate
            do
                handle_cmd $query
            done
            check_and_warn_boot_block
            ;;
        bootprogress)
            OBJECT=$STATE_OBJECT/host$G_INSTANCE_ID
            SERVICE=$(mapper get-service "$OBJECT")
            INTERFACE=$STATE_INTERFACE.Boot.Progress
            PROPERTY=BootProgress
            state_query "$SERVICE" "$OBJECT" $INTERFACE $PROPERTY
            ;;
        power)
            OBJECT=/org/openbmc/control/power0
            SERVICE=$(mapper get-service $OBJECT)
            INTERFACE=org.openbmc.control.Power
            for property in pgood state pgood_timeout; do
                # get_property can potentially return several
                # different formats of values, so we do the parsing outside
                # of get_property depending on the query. These queries
                # return 'i VALUE' formatted strings.
                STATE=$(get_property "$SERVICE" "$OBJECT" "$INTERFACE" "$property" | sed 's/i[ ^I]*//')
                printf "%s = %s\n" $property "$STATE"
            done
            ;;
        chassiskill)
            /usr/libexec/chassiskill
            ;;
        hostrebootoff)
            OBJECT=$CONTROL_OBJECT/host$G_INSTANCE_ID/auto_reboot
            SERVICE=$(mapper get-service "$OBJECT")
            INTERFACE=$CONTROL_INTERFACE.Boot.RebootPolicy
            PROPERTY=AutoReboot
            VALUE=false
            set_property "$SERVICE" "$OBJECT" $INTERFACE $PROPERTY "b" $VALUE
            ;;
        hostrebootoffonetime)
            OBJECT=$CONTROL_OBJECT/host$G_INSTANCE_ID/auto_reboot/one_time
            SERVICE=$(mapper get-service "$OBJECT")
            INTERFACE=$CONTROL_INTERFACE.Boot.RebootPolicy
            PROPERTY=AutoReboot
            VALUE=false
            set_property "$SERVICE" "$OBJECT" $INTERFACE $PROPERTY "b" $VALUE
            ;;
        hostrebooton)
            OBJECT=$CONTROL_OBJECT/host$G_INSTANCE_ID/auto_reboot
            SERVICE=$(mapper get-service "$OBJECT")
            INTERFACE=$CONTROL_INTERFACE.Boot.RebootPolicy
            PROPERTY=AutoReboot
            VALUE=true
            set_property "$SERVICE" "$OBJECT" $INTERFACE $PROPERTY "b" $VALUE
            ;;
        bmcrebootoff)
            disable_bmc_reboot
            ;;
        bmcrebooton)
            enable_bmc_reboot
            ;;
        recoveryoff)
            handle_cmd hostrebootoff
            handle_cmd bmcrebootoff
            mask_systemd_target $HOST_TIMEOUT_TARGET
            mask_systemd_target $HOST_CRASH_TARGET
            ;;
        recoveryon)
            handle_cmd hostrebooton
            handle_cmd bmcrebooton
            unmask_systemd_target $HOST_TIMEOUT_TARGET
            unmask_systemd_target $HOST_CRASH_TARGET
            ;;
        recoverystatus)
            host_reboot_state=$(get_host_reboot_status)
            if [[ $host_reboot_state == "b true" ]]; then
                host_reboot_status=1
            else
                host_reboot_status=0
            fi

            bmc_reboot_state=$(get_bmc_reboot_status)
            if [[ $bmc_reboot_state == "on" ]]; then
                bmc_reboot_status=1
            else
                bmc_reboot_status=0
            fi

            host_timeout_target_state=$(get_systemd_target_state $HOST_TIMEOUT_TARGET)
            if [[ $host_timeout_target_state == "masked" ]]; then
                host_timeout_status=0
            else
                host_timeout_status=1
            fi

            host_crash_target_state=$(get_systemd_target_state $HOST_CRASH_TARGET)
            if [[ $host_crash_target_state == "masked" ]]; then
                host_crash_status=0
            else
                host_crash_status=1
            fi

            if (( host_reboot_status && bmc_reboot_status && host_timeout_status && host_crash_status )); then
                echo "recovery: On"
            elif (( !host_reboot_status && !bmc_reboot_status && !host_timeout_status && !host_crash_status )); then
                echo "recovery: Off"
            else
                echo "recovery: Undefined"
            fi

            declare -A status
            status[0]="Off"
            status[1]="On"

            printf "  %-11s: %s\n" "hostReboot" "${status[$host_reboot_status]}"
            printf "  %-11s: %s\n" "bmcReboot" "${status[$bmc_reboot_status]}"
            printf "  %-11s: %s\n" "hostTimeout" "${status[$host_timeout_status]}"
            printf "  %-11s: %s\n" "hostCrash" "${status[$host_crash_status]}"
            ;;
        listbootblock)
            blockingErrors=$(check_boot_block_errors)
            if [ -z "$blockingErrors" ]; then
                echo "No blocking errors present"
            else
                echo "$blockingErrors"
            fi
            ;;
        listlogs)
            list_logs
            ;;
        showlog)
            show_log "$2"
            ;;
        deletelogs)
            delete_logs
            ;;
        stopofftargets)
            stop_off_targets
            ;;
        *)
            print_usage_err "Invalid command '$1'"
            ;;
    esac
}

shiftcnt=0
for arg in "$@"; do
    case $arg in
        -w|--wait)
            G_WAIT=30
            shiftcnt=$((shiftcnt+1))
            continue
            ;;
        -h|--help)
            print_help
            ;;
        -v|--verbose)
            G_VERBOSE=y
            shiftcnt=$((shiftcnt+1))
            ;;
        -i=*|--id=*)
            G_INSTANCE_ID="${arg#*=}"
            shiftcnt=$((shiftcnt+1))
            ;;
        -*)
            print_usage_err "Unknown option: $arg"
            ;;
        *)
            G_ORIG_CMD=$arg
            # shift out the optional parameters
            shift $shiftcnt
            # pass all arguments to handle_cmd in case command takes additional
            # parameters
            handle_cmd "$@"
            break
            ;;
    esac
done
