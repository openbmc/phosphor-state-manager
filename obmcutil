#!/bin/sh

OPTS="bmcstate,bootprogress,chassisoff,chassison,chassisstate,hoststate,\
power,poweroff,poweron,state,status"

USAGE="Usage: obmcutil [-h]
                {$OPTS}"

SERVICE_ROOT=xyz.openbmc_project
STATE_SERVICE=$SERVICE_ROOT.State

OBJECT_ROOT=/xyz/openbmc_project
STATE_OBJECT=$OBJECT_ROOT/state

print_help ()
{
    echo "$USAGE"
    echo ""
    echo "positional arguments:"
    echo "  {$OPTS}"
    echo ""
    echo "optional arguments:"
    echo "  -h, --help          show this help message and exit"
    echo "  -w, --wait          block until state transition succeeds or fails"
    exit 0
}

run_timeout ()
{
    local cmd="$1";
    local timeout="$2";

    if [[ $VALUE = "$STATE_SERVICE.Host"* ]]; then
        query="hoststate"
        if [[ $VALUE = *"On" ]]; then
            expected_state="$STATE_SERVICE.Host.HostState.Running"
        else
            expected_state="$STATE_SERVICE.Host.HostState.Off"
        fi
    elif [[ $VALUE = "$STATE_SERVICE.Chassis"* ]]; then
        query="chassisstate"
        if [[ $VALUE = *".On" ]]; then
            expected_state="$STATE_SERVICE.Chassis.PowerState.On"
        else
            expected_state="$STATE_SERVICE.Chassis.PowerState.Off"
        fi
    else
        # Should never hit this, more of a debug case...
        echo "Unable to match value: $VALUE"
    fi

    eval "$cmd"

    # Run a background query for the transition to the expected state
    # This will be killed if the transition doesn't succeed within
    # a timeout period.
    (
        while : ; do
            STATE=$(handle_arg $query)
            if grep -q $expected_state <<< "$STATE"; then
                break
            fi
        done
    ) &
    child=$!

    # Could be bad if process is killed before 'timeout' occurs if
    # transition doesn't succeed.
    trap -- "" SIGTERM

    # Workaround for lack of 'timeout' command.
    (
        sleep $timeout
        kill $child
    ) > /dev/null 2>&1 &

    wait $child

    rc=$?
    if [[ $rc != 0 ]]; then
        echo "Unable to confirm '$ROOT_COMMAND' success" \
        "within timeout period (${timeout}s)"
    fi
}

run_cmd ()
{
    local cmd="$1";

    if [ "$WAIT" == "y" ]; then
        local timeout=10
        run_timeout "$cmd" $timeout
    else
        eval $cmd
    fi
}

call ()
{
    run_cmd "busctl $1 | cut -d '\"' -f2"
}

set_property ()
{
    call "set-property $1 $2 $3 $4 $5"
}

get_property ()
{
    WAIT="n"
    call "get-property $1 $2 $3 $4"
}

state_query ()
{
    STATE=$(get_property $1 $2 $3 $4)
    printf "%-20s: %s\n" $4 $STATE
}

print_err ()
{
    echo "ERROR: $1" >&2
    echo "$USAGE"
    exit 1
}

handle_arg ()
{
    case "$1" in
        chassisoff)
            OBJECT=$STATE_OBJECT/chassis0
            SERVICE=$(mapper get-service $OBJECT)
            INTERFACE=$STATE_SERVICE.Chassis
            PROPERTY=RequestedPowerTransition
            VALUE=$INTERFACE.Transition.Off
            set_property $SERVICE $OBJECT $INTERFACE $PROPERTY "s $VALUE"
            ;;
        chassison)
            OBJECT=$STATE_OBJECT/chassis0
            SERVICE=$(mapper get-service $OBJECT)
            INTERFACE=$STATE_SERVICE.Chassis
            PROPERTY=RequestedPowerTransition
            VALUE=$INTERFACE.Transition.On
            set_property $SERVICE $OBJECT $INTERFACE $PROPERTY "s $VALUE"
            ;;
        poweroff)
            OBJECT=$STATE_OBJECT/host0
            SERVICE=$(mapper get-service $OBJECT)
            INTERFACE=$STATE_SERVICE.Host
            PROPERTY=RequestedHostTransition
            VALUE=$INTERFACE.Transition.Off
            set_property $SERVICE $OBJECT $INTERFACE $PROPERTY "s $VALUE"
            ;;
        poweron)
            OBJECT=$STATE_OBJECT/host0
            SERVICE=$(mapper get-service $OBJECT)
            INTERFACE=$STATE_SERVICE.Host
            PROPERTY=RequestedHostTransition
            VALUE=$INTERFACE.Transition.On
            set_property $SERVICE $OBJECT $INTERFACE $PROPERTY "s $VALUE"
            ;;
        bmcstate)
            OBJECT=$STATE_OBJECT/bmc0
            SERVICE=$(mapper get-service $OBJECT)
            INTERFACE=$STATE_SERVICE.BMC
            PROPERTY=CurrentBMCState
            state_query $SERVICE $OBJECT $INTERFACE $PROPERTY
            ;;
        chassisstate)
            OBJECT=$STATE_OBJECT/chassis0
            SERVICE=$(mapper get-service $OBJECT)
            INTERFACE=$STATE_SERVICE.Chassis
            PROPERTY=CurrentPowerState
            state_query $SERVICE $OBJECT $INTERFACE $PROPERTY
            ;;
        hoststate)
            OBJECT=$STATE_OBJECT/host0
            SERVICE=$(mapper get-service $OBJECT)
            INTERFACE=$STATE_SERVICE.Host
            PROPERTY=CurrentHostState
            state_query $SERVICE $OBJECT $INTERFACE $PROPERTY
            ;;
        state|status)
            for query in bmcstate chassisstate hoststate
            do
                handle_arg $query
            done
            ;;
        bootprogress)
            OBJECT=$STATE_OBJECT/host0
            SERVICE=$(mapper get-service $OBJECT)
            INTERFACE=$STATE_SERVICE.Boot.Progress
            PROPERTY=BootProgress
            state_query $SERVICE $OBJECT $INTERFACE $PROPERTY
            ;;
        power)
            OBJECT=/org/openbmc/control/power0
            SERVICE=$(mapper get-service $OBJECT)
            INTERFACE=org.openbmc.control.Power
            for property in pgood state pgood_timeout
            do
                # get_property can potentially return several
                # different formats of values, so we do the parsing outside
                # of get_property depending on the query. These queries
                # return 'i VALUE' formatted strings.
                STATE=$(get_property $SERVICE $OBJECT $INTERFACE $property \
                    | sed 's/i[ ^I]*//')
                printf "%s = %s\n" $property $STATE
            done
            ;;
        *)
            print_err "Invalid command '$1'"
            ;;
    esac
}

for arg in "$@"; do
    case $arg in
        -w|--wait)
            WAIT=y
            continue
            ;;
        -h|--help)
            print_help
            ;;
        -*)
            print_err "Unknown option: $1"
            ;;
        *)
            ROOT_COMMAND=$arg
            handle_arg $arg
            break
            ;;
    esac
done
